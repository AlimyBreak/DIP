# 6.1 图像压缩概述

+ 图像编码技术的研究背景
  + 信息传输方式发生了改变
    + 信息内容:语言+文字$\to $语音+文字+图像 
    + 通信对象: 人与人 $\to $ 人与机器、机器与机器
    
   + 图像传输与传输需要的空间越来越大
     + 彩色视频信息举例
     + 传真数据举例(2值图像)
     + 问题:
       + 传输带宽、速度、存储器容量限制
       + 如何用软件的手段来解决硬件上的物理极限.
     
   + 图像通信系统模型
  
     ```mermaid
     graph LR
     A(图像信息源)-->B(图像预处理)
     B-->C(图像信源编码)
     C-->D(信道编码)
     D-->E(调制)
     E-->F(信道传输)
     F-->G(解调)
     G-->H(信道解码)
     H-->I(图像信源解码)
     I-->J(显示图像)
     ```

+ 图像中的数据冗余
  + 只要接收端不产生误解，就可以减少承载信息的数据量.
  + 整理图像的描述方法可以达到压缩的目的.
  
  + 无损压缩的例子：$ 16*3*8bits \to (1+3)*8bits$ 
  + 有损压缩的例子:
    + 人眼的区分能有有限
    + $25*8 bits *\to 2*8 bits$

  + 视觉心理冗余:
    + 一些信息在一般视觉处理中比其他信息的相对重要程度要小，这种信息被称为视觉心理冗余.
    + 实例:彩色一共有$2^{8}*2^{8}*2^{8}=2^{24}=16777216$种颜色,但人眼能区分的只有几千种，太多的颜色我们无法区分.

  + 一幅图像存在__数据冗余__和__主管视觉冗余__,压缩方式就是从这两方面着手开展的.
    + 因为有数据冗余，将图像信息的描述方式改变以后，可以压缩掉这些冗余；
    + 因为有主观视觉冗余，当忽略一些视觉不太明显的微小差异，可以进行“有损”压缩.

+ 图像压缩及其必要性
  + 图像压缩:对图像源数据按一定的规则进行变换和组合，从而达到尽可能少的代码来表示尽可能多的数据信息。压缩通过__编码__实现，一般吧折现处理称之为__压缩编码__.
  
  + 必要性:一幅模拟图像必须经过脉冲编码调制(PCM-Pulse Code Modulation)才能变成数字图像.又他妈开始讲通信.
  
  + PCM过程:
  
    ```mermaid
    graph LR
    A(模拟图像)--空间采样-->B(中间体)
    B--幅值量化-->C(中间体)
    C--编码-->D(数字图像)
    ```
    设一幅活动图像的像素总数$k=512*512$,灰度分辨率为$b=8$,时间分辨率为$f_B=25(帧/s）$,该图像在传输通道里的传输率至少应该是$\rho = Kbf_B = 6.25 M/s$
  
+ 图像压缩分类

  + 应用角度
    + 静止图像编码
    + 活动图像编码
    + 二值图像编码
  + 信息保持角度
    + 有损压缩
    + 无损压缩
  + 编码技术角度
    + 空域法
    + 变换域法
    + 预测编码
    + 变换编码
    + 统计编码









# 6.2 图像保真度准则与压缩性能参数

+ 保真度准则

  + 图像品质的核心问题是__逼真度问题__.经过处理的图像(包括经过压缩编码后的图像)与一个标准图像之间的偏差可以作为图像逼真度的度量

  + 这一偏差，包括__亮度、色度、分辨率__以及某些心理物理学参数。偏差应该在允许的范围之内.

  + __客观保真度准则__

    + 设$f(x,y)$是输入图像,$f'(x,y)$是解码后输出的图像，定义偏差$e(x,y)=f(x,y)-f'(x,y)$,则一下参数(总偏差，均方差、军方信噪比)可作为保真度准则:
      $$
      \sum_{x}\sum_{y}|e(x,y)|\\
      \frac{1}{N^2}\sum_{x}\sum_{y}e^{2}(x,y)\\
      \frac{\sum_{x}\sum_{y}{f'}^2(x.y)}{\sum_{x}\sum_{y}e^2(x,y)}
      $$

  + __主观保真度准则__

    + 挑选一定数量的观察者对照片评价







+ 性能参数

  + 图像平均信息熵$H(d)$

    + 令$d=\{d_1,d_2,\cdots,d_m\}$是图像像素灰度级集合
    + 对应频率为$p(d_1),p(d_2),\cdots,p(d_m)$
    + 定义$H(d)=-\sum_{i=1}^{m}p(d_i)\log_2p(d_i)$
    + 单位为：比特/像素
    + 艹，定义了用来干啥啊

  + 平均码长(平均编码长度)$R(d)$

    + 令$\{\beta_1,\beta_2,\cdots,\beta_m\}$是$d_i,i=1,2,\cdots,m$对应灰度级的编码长度
    + 定义$R(d)=\sum_{i=1}^{m}p(d_i)\beta_i$
    + 单位为：比特/像素

  + 冗余度$r$
    $$
    r=\frac{原始图像平均码长}{原图图像的平均信息熵}-1=\frac{R(d)}{H(d)}-1
    $$

  + 编码效率$\eta$
    $$
    \eta = \frac{H(d)}{R(d)}=\frac{1}{1+r}
    $$

+ 冗余分类
  + 编码冗余
    + 符号序列 码字长度
  + 像素间相关性冗余
    + 帧间像素信息冗余，帧内像素信息冗余
  + 视觉冗余
    + 人眼对所有视觉信息并不是都具有相同的敏感度
    + 人眼的空间分辨率和时间分辨率有限.

  + 消除冗余能达到数据压缩的效果.





# 6.3 统计编码方法

+ 统计编码
  + 根据__图像像素灰度出现的概率__分布特性而进行的压缩编码.
  + 熵与平均码长的关系
    + $H(d)\lt R(d)$时,一定可以设计出某种平均码字更短的无失真编码方法
    + $H(d) \gt R(d)$的无失真编码方法不存在.
  + 熵编码
    + __使编码后的图像的平均码字长度金肯接近图像的熵$H(d)$.
    + 基本思路:
      + 概率大的灰度级用__短码字__，概率小的，用__长码字__.


+ 行程编码($RLE$编码)
  + 基本原理:
    + 通过改变图像的描述方法,来实现压缩.
    + 将一行中颜色相同的相邻像素用一个计数值和该颜色值代替.
  + 举例:
    + $aaaabbbccdeeeeefffffff \to 4a3b2c1d5e7f$
  + 适合行程较长的图像，一般不单独使用.


+ Huffman编码(熵编码,)
  + 基本原理:吧图像中出现频率大的像素值给一个短的编码,将出现频率小的像素值给一个比较长的编码.
  
  ```mermaid
  graph LR
  A(原图像输入)-->B(概率统计)
  B-->C(构造H树)
  C-->D(生成H树)
  D-->E(编码压缩)
  E-->F1(编码)
  E-->F2(传输)
  F1-->G(解码复原)
  F2-->G
  ```
  + 算法流程
    + $1.$将灰度级按概率大小进行排序(降序),每个灰度级作为一个叶子节点,行程一棵树;
    + $2.$将两个根节点最小的树合并,合并规则:这两个极点构造一个双亲节点,双亲节点的概率大小为两者之和,重复$1.$和$2.$,知道只有一个树为止.
    + $3.$设所有左后代为$0$,右后代为$1$.

  + 优点:即时码,最优码.
  
  + 缺点:当需要对大量符号进行编码时,构造最优霍夫曼码的计算量会很大.
  
  + 例题
    + 已知条件 
  
    | 灰度级 | $x_1$ | $x_2$ | $x_3$ | $x_4$ | $x_5$ | $x_6$ | $x_7$ | $x_8$ |
    | :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
    |  概率  | 0.40  | 0.18  | 0.10  | 0.10  | 0.07  | 0.06  | 0.05  | 0.04  |
    
    + 首先$x_7$和$x_8$合并,$x_7$在左边,$x_8$在右边,合并后概率为0.09,$x_5$和$x_6$合并,$x_5$在左边,$x_6$在右边,合并后概率为0.12

    | 灰度级 | $x_1$ | $x_2$ | $x_3$ | $x_4$ | $x_{(56)}$ | $x_{(78)}$ |
    | :----: | :---: | :---: | :---: | :---: | :------: | :------: |
    |  概率  | 0.40  | 0.18  | 0.10  | 0.10  |   0.13   |   0.09   |
    
    + $x_4$与$x_{(78)}$合并,$x_4$在左,$x_{(78)}$在右,合并后概率为0.19,$x_3$与$x_{(56)}$合并,$x_{(56)}$在左,$x_3$在右，合并后概率为$0.33$
    | 灰度级 | $x_1$ | $x_2$ | $x_{((56)3)}$ | $x_{(4(78))}$ |
    | :----: | :---: | :---: | :---: | :---: |
    |  概率  | 0.40  | 0.18  | 0.23  | 0.19 |

    + $x_2$与$x_{4(78)}$合并,$x_{4(78)}$在左,$x_2$在右,合并后概率为$0.37$
    | 灰度级 | $x_1$ | $x_{(((4(78)))2)}$ | $x_{((56)3)}$ |
    | :----: | :---: | :---: | :---: |
    |  概率  | 0.40  | 0.37  | 0.23  |

    + $x_{(((4(78)))2)}$ 和 $x_{((56)3)}$ 合并,$x_{(((4(78)))2)}$在左,$x_{((56)3)}$在右,合并以后概率为$0.60$
    | 灰度级 | $x_1$ | $x_{ ( (((4(78)))2)((56)3))}$ |
    | :----: | :---: | :---: |
    |  概率  | 0.40  | 0.60  |

    + $x_{ ( (((4(78)))2)((56)3))}$ 和 $x(1)$ 合并 $x_{ ( (((4(78)))2)((56)3))}$ 在左,$x(1)$在右,合并以后概率为$1.00$

    | 灰度级 | $x_{ (( (((4(78)))2)((56)3)) (1)  )}$ |
    | :----: | :---: |
    |  概率  | 1.00  |

    + $x_1$是根节点的右节点,编码为$1$
    + 左节点全部加一个0，$0((((4(78)))2)((56)3))$
    + $00(((4(78)))2) $ 及$01((56)3))$
    + $000((4(78))) \ \ \ \ 0012$  $x_2$的编码为$001$
    + $010(56)\ \ \ \ 0113$,$x_3$的编码为$011$
    + $01005\ \ \ \ 01016 $,$x_5$的编码为$0100$,$x_6$的编码为$0101$
    + $00004\ \ \ \ 0001(78)$,$x_4$的编码为$0000$,$x_7$的编码为$00010$.$x_8$的编码为$00011$





# 6.4 预测编码与变换编码压缩

+ 预测编码
  + 根据“过去”时刻的像素值，运用一种模型，预测当前的像素值，预测编码通常不直接对信号编码，而是对预测误差进行编码，当预测比较准确，误差较小时，即可达到编码压缩的目的.
  + ... 没看懂，算了.
+ 变换编码:正交变换后去掉不重要的部分.