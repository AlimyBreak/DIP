# 7.1 边缘检测

+ 边缘的定义

  + 图像中像素灰度由阶跃变化或屋顶变换的那些像素的集合。

+ 边缘的分类

  + 阶跃状:
    + 灰度分布一维阶跃函数
    + 一阶导数：在边缘处取到极值
    + 二阶导数：在边缘处零交叉
  + 屋顶状:
    + 灰度分布正态状函数
    + 一阶导数：在边缘处零交叉
    + 二阶导数：在边缘处取到极值

+ 相关算子

  + 梯度算子

    + 函数$f(x,y)$在$(x,y)$处的梯度为一个向量
      $$
      \nabla f = \left[ \frac{\partial{f}}{\partial{x}},\frac{\partial{f}}{\partial{y}} \right]
      $$

    + 梯度大小为:
      $$
      grad(x,y)=\left[ \left( \frac{\partial{f}}{\partial{x}}\right)^2 +\left( \frac{\partial{f}}{\partial{y}}\right)^2 \right]^{\frac{1}{2}}
      $$

    + 也可以近似的表示为
      $$
      grad(x,y)\approx|\partial{f_x} |+|\partial{f_y} |\\
      grad(x,y)\approx \max(|\partial{f_x} |,|\partial{f_y} |);
      $$

    + 梯度的方向为$\phi{(x,y)}=\tan^{-1}(\frac{\partial{f_y}}{\partial{f_x}})$

    + 梯度分量用模板表示为
      $$
      [-1,1],[-1,1]^T
      $$
      
    + 为了检测边缘点,选取适当的阈值$T$,对梯度图像进行二值化,则形成了一幅边缘二值图像
    $$
    g(x,y)=
    \begin{cases}
    1,grad(x,y) \ge T \\
    0,other
    \end{cases}
    $$
    
    + 特点:仅计算相邻像素的灰度差,对噪声比较敏感,无法抑制噪声的影响.
    
    
    
  + Roberts算子(45度角的梯度)
    
    + 公式
    $$
    f_x' = |f(x+1,y+1)-f(x-1,y-1)| \\
    f_y' = |f(x-1,y+1)-f(x+1,y-1)|
    $$
    
    + 模板
      $$
      \left[
      \begin{matrix}
      -1 & 0 \\
      0 & 1
      \end{matrix}
      \right],
      \left[
      \begin{matrix}
      0 & 1 \\
      -1 & 0
      \end{matrix}
      \right]
      $$
    
    + 特点:与梯度算子检测边缘的方法类似,对噪声敏感,但效果较梯度算子略好。
    
    
    
  + PreWitt算子(3*3模板)
  
    + 公式
    $$
    f_x'=|f(x+1,y-1)+f(x+1,y)+f(x+1,y+1) \\-f(x-1,y-1)-f(x-1,y)-f(x-1，y+1)|\\
    f_y'=|f(x+1,y+1)+f(x,y+1)+f(x-1,y+1) \\-f(x-1,y-1)-f(x,y-1)-f(x+1，y-1)|
    $$
    
    + 模板
    $$
    \left[ 
    \begin{matrix}
    -1 & 0 & 1 \\
    -1 & 0 & 1 \\
    -1 & 0 & 1
    \end{matrix}
    \right],
        \left[ 
    \begin{matrix}
    -1 & -1 & -1 \\
    0 & 0 & 0 \\
    1 & 1 & 1
    \end{matrix}
    \right],
    $$
    
    + 特点:计算梯度的时候考虑了邻域的影响,在检测边缘的同时,能有效抑制噪声.
    
  + Sobel算子(带权邻域来计算梯度,四邻域的权值为2,八邻域的权值为1)
    
    + 公式
    $$
    f_x'=|f(x+1,y-1)+2f(x+1,y)+f(x+1,y+1) \\-f(x-1,y-1)-2f(x-1,y)-f(x-1，y+1)|\\
    f_y'=|f(x+1,y+1)+2f(x,y+1)+f(x-1,y+1) \\-f(x-1,y-1)-2f(x,y-1)-f(x+1，y-1)|
    $$
    
    + 模板
    $$
    \left[ 
    \begin{matrix}
    -1 & 0 & 1 \\
    -2 & 0 & 2 \\
    -1 & 0 & 1
    \end{matrix}
    \right],
        \left[ 
    \begin{matrix}
    -1 & -2 & -1 \\
    0 & 0 & 0 \\
    1 & 2 & 1
    \end{matrix}
    \right],
    $$
    
    + 特点:对四领域采用带权方法计算差分,能进一步抑制噪声,但__检测到的边缘较宽__.



  + Kirsch算子(方向算子)
    + 方向模板(八个箭头方向,沿着箭头方向,左边为负,右边为正)
    $$
    \left[ 
    \begin{matrix}
    -5 & 3 & 3 \\
    -5 & 0 & 3 \\
    -5 & 3 & 3
    \end{matrix}
    \right],
    \left[ 
    \begin{matrix}
    3 & 3 & 3 \\
    -5 & 0 & 3 \\
    -5 & -5 & 3
    \end{matrix}
    \right],
    \left[ 
    \begin{matrix}
    3 & 3 & 3 \\
    3 & 0 & 3 \\
    -5 & -5 & -5
    \end{matrix}
    \right],
    \left[ 
    \begin{matrix}
    3 & 3 & 3 \\
    3 & 0 & -5 \\
    3 & -5 & -5
    \end{matrix}
    \right]\\
    
    \left[ 
    \begin{matrix}
    3 & 3 & -5 \\
    3 & 0 & -5 \\
    3 & 3 & -5
    \end{matrix}
    \right],
    \left[ 
    \begin{matrix}
    3 & -5 & -5 \\
    3 & 0 & -5 \\
    3 & 3 & 3
    \end{matrix}
    \right],
    \left[ 
    \begin{matrix}
    -5 & -5 & -5 \\
    3 & 0 & 3 \\
    3 & 3 & 3
    \end{matrix}
    \right],
    \left[ 
    \begin{matrix}
    -5 & -5 & 3 \\
    -5 & 0 & 3 \\
    3 & 3 & 3
    \end{matrix}
    \right]
    $$
    
    + 该方法取积和运算的__最大值__为边缘强度,而将与之对应的模板方向作为__边缘方向__.
    + 在计算边缘强度的同时可以得到边缘的方向,各方向间的夹角为$\frac{\pi}{4}$.
    
  + Nevitia算子(和Kirsch算子类似,只不过夹角是\frac{\pi}{6})
    
    + 方向模板(一共该由十二个,就不一个一个抄了)
    $$
    \left[
    \begin{matrix}
    -100 & -100 & 0 & 100 & 100 \\
    -100 & -100 & 0 & 100 & 100 \\
    -100 & -100 & 0 & 100 & 100 \\
    -100 & -100 & 0 & 100 & 100 \\
    \end{matrix}
    \right]\\
    
    \left[
    \begin{matrix}
    -100 & -78 & 92 & 100 & 100 \\
    -100 & -100 & 0 & 100 & 100 \\
    -100 & -100 & -92 & 78 & 100 \\
    -100 & -100 & -100 & -32 & 100 \\
    \end{matrix}
    \right]\\
       
    \left[
    \begin{matrix}
    -32 & 78 & 100 & 100 & 100 \\
    -100 & -92 & 0 & 92 & 100 \\
    -100 & -100 & -100 & -78 & 32 \\
    -100 & -100 & -100 & -100 & 100 \\
    \end{matrix}
    \right]\\
    ...
    $$
    
  + 拉普拉斯算子	
    
    + 对于阶跃边缘,其二阶导数在边缘点出现零交叉，并且在边缘点出两边像素的二阶导数异号.
    
    + 定义:
    $$
    \nabla{^2f}=\left[\frac{\partial{^2f}}{\partial{x^2}},\frac{\partial{^2f}}{\partial{y^2}}\right]
    $$
    
    + 离散形式:
    $$
    \nabla{^2f(x,y)}=f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)
    $$
    
    + 模板
    $$
    \left[
    \begin{matrix}
    0  & 1 & 0 \\
    1 & -4 & 1 \\
    0 & 1 & 0
    \end{matrix}
    \right]
    $$
    
    + 优点
      + 各向同性,线性和位移不变的
      + 对细线和孤立点检测效果较好;
    + 缺点:
      + 对噪声的敏感,对噪声由双倍加强作用
      + 不能检测出边的方向
      + 常产生双像素的边缘
    + 由于梯度算子和拉普拉斯算子都对噪声敏感，因此一般在用他们检测边缘前要先对图像进行__平滑__.
    
  + Marr算子(高斯+拉普拉斯算子)
    + 由于拉普拉斯算子对噪声比较敏感,为了减少噪声影响,可先对图像进行平滑,然后再进行拉普拉斯算子检测边缘.
    + 平滑函数采用正太分布的高斯函数,即
    $$
    h(x,y)=e^{-\frac{x^2+y^2}{2\sigma{^2}}}
    $$
    
    + 用$h(x,y)$对图像$f(x,y)$的平滑可以表示为
    $$
    g(x,y)=h(x,y)\star f(x,y)
    $$
    其中$\star$表示卷积.令$r$是离原点到径向距离,即$r^2=x^2+y^2$,对图像$g(x,y)$再采用拉普拉斯算子进行边缘检测.就可以得到
    $$
    \begin{eqnarray}
    \nabla^2g&=&\nabla^2\left[h(x,y)\star f(x,y)\right] = (-\frac{r^2-\sigma^2}{\sigma^4})e^{-\frac{r^2}{2\sigma^2}}\star f(x,y)\\
    &=&\nabla^2h\star f(x,y)
    \end{eqnarray}
    $$
    这样,利用二阶导数算子过零点的性质，可确定图像中阶跃边缘的位置.
    
    + $\nabla^h$被称为__高斯-拉普拉斯__滤波算子,也被称为$LoG$滤波器,或者__墨西哥草帽__.
    
    + 由于Marr算子的平滑性质能减少噪声,所以当边缘模糊或噪声较大时,利用Marr算子检测过零点提高可靠的边缘位置.
    + 在该算子中$\sigma$的选择很重要,$\sigma$小时边缘精度高,但边缘细节变化多;$\sigma$大时平滑作用大,但细节损失大,边缘点定位精度低
    + 应该根据噪声水平和边缘定位精度适当选择$\sigma$
    + Marr算子的卷积模板一般较大,其半径一般为$8\~32$.
    
  + 曲面拟合法
    + 出发点:基于差分检测图像边缘的算子__往往对噪声敏感__.因此对一些噪声比较严重的图像难以取得满意的效果.
    
    + 若采用屏幕或高阶曲面来拟合图像中某一区域的灰度表明,求这个拟合平面或曲面外法方向的微分或二阶微分检测边缘,可减少噪声影响。
    
    + __四点拟合灰度平面法__:
    
      + 若用一个平面$p(x,y)=ax+by+c$来拟合空间四邻像素的灰度值$f(x,y),f(x,y+1),f(x+1,y),f(x+1,y+1)$，则均方差为:
      $$
      \epsilon = \sum{\left[p(x,y)-f(x,y)\right]^2}  
      $$
      + 按照__均方差最小准则__,可以求解参数$a,b,c$.经推导得到(好吧,直接抄下来).
      
      $$
      \begin{eqnarray}
      2a &=&  [f(x+1,y)+f(x+1,y+1)] - [f(x,y)+f(x,y+1)]  \\ 
      2b &=& [f(x,y+1)+f(x+1,y+1)] - [f(x,y)+f(x+1,y)]   \\
      4c &=& 3f(x,y)+f(x+1,y)+f(x,y+1)
      \end{eqnarray}
      $$
      
      + $a,b$对应的模板为:
      $$
      \left[
      \begin{matrix}
      -1 & -1 \\
      1 & 1
      \end{matrix}
      \right],
      \left[
      \begin{matrix}
      -1 & 1 \\
      -1 & 1
      \end{matrix}
      \right]
      $$
      
      + 按照梯度的定义,由平面$p(x,y)=ax+by+c$的偏导数很容易求得梯度,其近似表达式为
      $$
      g(x,y)=|a|+|b|
      $$
      
      + 特点:
        + 其过程是__求平均后再求差分__,因而对噪声有抑制作用.
        + 用模板对图像求卷积进行边缘检测,计算$a,b$对应的模板为
        $$
        \frac{1}{2}
        \left[
        \begin{matrix}
        -1 & -1 \\
        1 & 1
        \end{matrix}
        \right],
        \frac{1}{2}
        \left[
        \begin{matrix}
        -1 & 1 \\
        -1 & 1
        \end{matrix}
        \right]
        $$
    
+ 线的检测
  + 通过比较模板的卷积和计算值,确定一个点是否正在某个方向上.
  + 模板
  $$
  \left[
  \begin{matrix}
  -1 & -1 & -1 \\
  2 & 2 & 2 \\
  -1 & -1 & -1
  \end{matrix}
  \right],
  
  \left[
  \begin{matrix}
  -1 & -1 & 2 \\
  -1 & 2 & -1 \\
  2 & -1 & -1
  \end{matrix}
  \right],
  
  \left[
  \begin{matrix}
  -1 & 2 & -1 \\
  -1 & 2 & -1 \\
  -1 & 2 & -1
  \end{matrix}
  \right],
  
  \left[
  \begin{matrix}
  2 & -1 & -1 \\
  -1 & 2 & -1 \\
  -1 & -1 & 2
  \end{matrix}
  \right]
  $$
  
  + 我们通过计算四个模板的卷积结果,获取最大值是否大于某个门限，来判断是否是某种方向的线条。





# 7.2 Hough变换

+ 检测直线，针对图像上的边缘点，找出其共线的点集及其直线方程.

  + 对于直角坐标系中的一条直线$l$,原点到该直线的垂直距离是$\rho$,垂线与$x$轴的夹角为$\theta$,可以用$\rho,\theta$表示该直线，直线方程为:
    $$
    \begin{eqnarray}
    \rho   &=& x\cos\theta +y\sin \theta \\
    \rho   &=& x\frac{x_0}{\rho}+y\frac{y_0}{\rho}\\
    \rho^2 &=& xx_0+yy_0\\
    &=&[x,y][x_0,y_0]^T
    \end{eqnarray}
    $$

  + $\rho^2=[x,y][x_0,y_0]^T$表示从零点到$l$上任意一点$(x,y)$构成的向量在从零点到垂点构成的向量上的向量投影，显然$(32)$为恒等式,即$(29)$恒成立.

  + 所以$l$这条直线用极坐标表示$(\rho,\theta)$,就是一个点.直角坐标系中的一条直线，对应极坐标系中一个点.

  + 线到点的变换，就是Hough变换.

  + 在直角坐标系中，有任意过一点$(x_0,y_0)$至直线系，这些直线满足:
    $$
    \rho= x_0\cos\theta+y_0\sin\theta=(x_0^2+y_0^2)^{\frac{1}{2}}\sin(\theta+\phi)
    $$
    其中:
    $$
    \phi = \arctan\left(\frac{y_0}{x_0}\right)\\
    $$
  
  + 这些直线在极坐标系中对应的点$(\rho,\theta)$构成一条正弦曲线:

    

    ![正弦曲线](%E7%AC%AC07%E7%AB%A0_%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2.assets/%E6%AD%A3%E5%BC%A6%E6%9B%B2%E7%BA%BF.jpg)

    
    
  + 正弦曲线上的一点对应直角坐标系中过$(x_0,y_0)$
  
  + 如果图像中有若干个点，过每个点的直线系分别对应于极坐标下的一条曲线，如果这些正弦曲线有一个共同的交点$(\rho',\theta')$,则这些点共线，且该直线方程为:
    $$
    \rho'=x\cos\theta'+y\sin\theta'
    $$
  
  + Hough变换的实现步骤如下:
  
    + 在$\rho,\theta$极值范围内对其分别进行$m,n$等分，并设一个二维数组$A(m,n)$,用来统计交点计数值.
    + 对图像上的所有边缘点做Hough变换，求每个点在$\theta_j(j=0,1,...,n-1)$Hough变换后的$\rho_i$,判断$(\rho_i,\theta_j)$与哪个元素对应，则改数组元素值加1.
    + 比较数组元素值的大小，最大值所对应的$(\rho_i,\theta_j)$，就是这些共线点对应的直线方向的参数.
  
  + 算法特点：
  
    + 对$\rho,\theta$量化过粗，直线参数就不精确，过细则计算量增加，因此，对$\rho,\theta$的量化要兼顾参数量化精度和计算量.
    + Hough变换检测直线的抗噪性能强，能够将断开的边缘连接起来.
    + Hough变换也能用于检测曲线.
  
+ Hough变换的扩展

  + Hough变换不只对直线，也可以用于圆:

    + 圆的方程为$(x-a)^2+(y-b)^2=R^2$，与直线相比，圆的参数有$a,b,R$三个，这时参数空间就增加到三维.

    + 若按照直线处理，运算量较大，解决途径:

      + 若已知图的边缘(当然图中还有其他非圆的边沿点混在一起)，而且边缘方向已知，则可以减少一维，把上式对$x$取导数，有
      
      $$
      2(x-a)+2(y-b)\frac{dy}{dx} = 0
      $$
      
      + $(36)$式表示参数$a,b$不独立,只需要用两个参数(例如$a$和$R$)组成参数空间，计算量就缩减很多.

  + Hough变换不只对直线，也可以用于椭圆:     
  
    + 椭圆的方程为$\frac{(x-x_0)^2}{a^2}+\frac{(y-y_0)^2}{b^2} = 1$
    
    + 取导数有:
    $$
    \frac{x-x_0}{a^2}+\frac{y-y_0}{b^2}\frac{dy}{dx}=0
    $$
    
    + 已知道椭圆上一点，则只有三个独立参数，只需要从$(a,b,x_0,y_0)$中选取三个参数进行检测.
      
    
  + 对于任意曲线,
    
    + 在形状物中可确定一个任意点$(x_c,y_c)$为参考点，从边界上任一点$(x,y)$到参考点$(x_c,y_c)$的长度为$r$,它是$\phi$的函数,其中$\phi$是$(x,y)$边界点上的梯度方向.
    
    + 通常把$r$表示为$\phi$的参数方程$r(\phi)$,$(x_c,y_c)$到边界连线的角度为$\alpha(\phi)$,则$(x_c,y_c)$应该满足
    $$
    x_c = x + r(\phi)\cos a \\
    y_c = y + r(\phi)\sin a
    $$
    
    + 对于某已知的边界$R$,可以按$\phi$的大小列成一个二维表格,即$\phi_i \sim (a,r)$表,$\phi_i$确定后可以查出$a$和$r$,经过$(38)$可算得$(x_c,y_c)$
    
    +  对已知形状建立了$R$表格后，开辟一个二维存储区，对未知图像个点都来查已建立的$R$表，然后计算$(x_c,y_c)$,若未知图像各店计算出的$(x_c,y_c)$很集中，就表示已经找到该形状的边界，集中的程度就是找最大值.
    
      + 对将要寻找的某物边界建立$R$表，这是一个二维表，以$\phi_i$的步进值求$r$和$\alpha$;
    
      + 在需要判断被测图像中有无已知某物时，也可对该图某物各点在内存中建立一存储区，存储内容是累加的，把$x_c,y_c$从最小到最大用步进表示，并作为地址，记作$A(xcmin\sim max,ycmin\sim max)$,存储阵列内容初始化为零.
    
      + 对图像边界上每一点$(x_i,y_i)$,计算$\phi(x)$,查原来的$R$计算$(x_c,y_c)$
        $$
        x_c = x + r(\phi)\cos[a(\phi)] \\
        y_c = y + r(\phi)\sin[a(\phi)]
        $$
    
      + 使相应的存储阵列$A(x_c,y_c)$加1.
    
      + 在这列中找一最大值，就找出了图像中符合要找的某物体边界.





# 7.3  区域分割(基于阈值)

+ 简单图像、复杂图像的区域分割

+ 简单图像的区域分割

  + 最简单图像$f(x,y)$,灰度阈值$T$
    $$
    g(x,y)=
    \begin{cases}
    1,f(x,y)\le T\\
    0,other
    \end{cases}
    $$
    
  + 如何确认$T$
    + 状态法(峰谷法)
      + 统计图像的灰度直方图，若直方图为双峰，且有明显的谷；
      + 将谷所对应的灰度值作为阈值，再按上面的公示进行二值化.
      + 适合于目标与背景的灰度差别较大，且直方图有明显波谷的情况.
      + 在应用中，为了便于阈值的选取,可采用__灰度加权__的方法产生新的直方图,得到更大的峰谷比.
      
    + 判断分析法
      + 假定最简单图像$f(i,j)$的灰度区间为$[0,L-1]$,选取一阈值$t$讲图像的像素分为$c1,c2$两组,其中$c1$组像素数为$w1$,$c2$组像素数为$w2$;
      + 图像总像素数$w1+w2$,灰度均值为$m=\frac{(m1w1+m2w2)}{w1+w2}$
      + 组内方差为:$\sigma_w^2 = w1\sigma_1^2 + w_2\sigma_2^2$
      + 组间方差为:$\sigma_B^2 = w1(m1-m)^2 + w2(m2-m)^2=w1w2(m1-m2)^2$
      + 组内方差越小,组内像素越相似,组间方差越大,则两组的差别越大.
      + 故$\frac{\sigma_B^2}{\sigma_w^2}$的值越大,表明分割效果越好.
      + 改变$t$的取值,使得$\frac{\sigma_B^2}{\sigma_w^2}$最大,这时所对应的$t$,就是分割的阈值.
      + 判断分析法比较便利,是一种常用的方法,但它不能反映图像的集合结构，有时候的分割结果与人的视觉效果不一致.
    
    + 最小误差分割
      + 设图像中背景像素的灰度级服从正态分布,概率密度为$p_1(z)$,均值和方差分别为$\mu_1$和$\sigma_1^2$,感兴趣目标的像素灰度级服从正态分布,概率密度为$p_2(z)$,均值和方差分别为$\mu_2$和$\sigma_2^2$.
      + 设背景像素数占图像总像素数的百分比为$\theta$,目标像素数占$(1-\theta)$,则混合概率密度为:
      
      $$
      p(z)=\theta p_1(z) +(1-\theta)p_2(z) = \frac{\theta}{\sqrt{2\pi}\sigma_1}e^{\frac{-(z-\mu_1)^2}{2\sigma_1^2}} + \frac{1-\theta}{\sqrt{2\pi}\sigma_2}e^{\frac{-(z-\mu_2)^2}{2\sigma_2^2}}
      $$
      
    + 当选定阈值为$t$时,目标像素错分为背景像素的概率为: 
    $$
    E_2(t) = \int_{-\infty}^{t}p_2(z)dz
    $$
    把背景像素错分为目标像素的概率为:
    $$
    E_1(t)=\int_{t}^{+\infty}p_1(z)dz
    $$
    
    + 则总误差概率为:
    $$
    E(t)=\theta E_1(t) + (1-\theta)E_2(t)
    $$
    
    + 为使得$E(t)$最小,可以令$\frac{\partial{E(t)}}{\partial{t}}=0$,即
    $$
    -\theta p_1(t) + (1-\theta)p_2(t)=0
    $$
    当$\sigma_1^2 = \sigma_2^2 = \sigma^2$时,有$t=\frac{\mu_1+\mu_2}{2}+\frac{\sigma^2}{\mu_2 - \mu_1}\ln\frac{\theta}{1-\theta}$
    若先验概率已知,l例如$\theta=\frac{1}{2}$,则有$t=\frac{\mu_1+\mu_2}{2}$
    

+ 复杂图像的区域分割
  
   + 目的:多阈值分割
   + 分割步骤:
     + 自动平滑直方图
     一般来说,待分析图像的灰度直方图不是很平滑，这对自动寻找峰与下一步确定阈值带来困难，因此有必要对直方图进行平滑，一般来说，可以采用__空间滤波器__与直方图做卷积来进行平滑.
     
     + 确定区域类数
     对于灰度层次不多的图像,一个区域类通常对应直方图中的一个峰,但是平滑后的直方图中的每一个峰不一定都对应一个区域类,因而有必要通过检查认定峰对应的区域类.

     + 自动搜索多个阈值
     可以采用前面介绍过的判断分析法,依次计算各峰两两之间的最佳阈值，然后再用这组阈值分割原始图像.



+ 特征空间聚类

  + 利用特征空间聚类进行图像分割,可以看成是阈值分割概念的推广.
    + 将图像空间中的像素用对应的特征空间点表示
    + 根据他们在特征空间的聚集情况对特征空间进行图像分割
    + 最后将他们映射会原图像空间, 得到分割的结果.
    
  + K均值聚类算法步骤
    + 任意选择$K$个初始类均值,$\overrightarrow{Z}_1,\overrightarrow{Z}_2,...,\overrightarrow{Z}_K$
    + 使用最小距离判别法将任一样本分给$K$类中的某一类,若对所有的$i\ne j$,有$|\overrightarrow{x}-\overrightarrow{Z}_i| \lt |\overrightarrow{x}-\overrightarrow{Z}_j|$，则$\overrightarrow{x}$属于第$i$类.
    + 根据分类结果，计算各类均值，并以此作为新的类均值.
    + 比较新旧类均值,若他们之差小于某一阈值，则认为中心已经稳定，可以终止算法，输出结果，否则继续使用最小判别法进行分类.
  



## 7.4  区域增长(区域扩张法)

+ 基本原理:

  + 先把图像分割成若干个小区域，
  + 然后比较相邻小区域特征是否相似，若他们足够相似，则作为同一个区域合并，以此将特征相似的小区域不短合并，直到不能合并为止，最后形成特征不同的区域.

+ 区域增长根据所用的邻域方式和相似性准则的不同，产生各种不同的区域扩张法.

  + 单一型(像素与像素)
  + 质心型(像素与区域)
  + 混合型(区域与区域)

  

+ 简单区域生长(以像素灰度为特征的简单区域增长法)

  + 对图像进行光栅扫描，求出不属于任何区域的像素，当寻找不到这样的像素时结束操作.
  + 把这个像素灰度同其4-邻域或8-邻域中不属于其他区域的像素进行比较，若灰度差值小于阈值，则合并到同一区域，并对合并的像素赋予标记.
  + 从新合并的像素开始，反复进行上一步的操作.
  + 反复进行上两步的操作，直到不能再合并
  + 返回到第一步，寻找新区域出发点的像素.
  + 若两个区域之间的灰度变化比较平缓，则两个区域容易被合并成一个区域，为了规避这个问题，在第二步中，改为比较已存在区域的平均灰度与该前一天有邻接的像素灰度值.

+ 质心型区域生长(就是简单区域生长的改进)

  + 缺点：区域增长的结果与起始像素有关，起始位置不同，在分割结果有差异.

+ 混合型区域增长

  + 把图像分割成小区域，比较相邻的小区域的相似性，相似则合并，知道不能合并位置.
  + 不依赖于起始点的方法
    + 设灰度差的阈值为0，用简单区域扩张法把具有相同灰度的像素合并到同一区域，得到图像的初始分割图像.
    + 从分割图像的一个小区域开始，求出相邻区域间的灰度差，将差值最小的区域合并.
    + 反复进行第二步，把区域依次合并，适当阶段停止合并，得到分割图像.
  + 假设检验法(根据图像子块内的灰度分布的相似性进行子块合并，最终实现图像的分割)
    + 把图像分割成不交迭、大小为$n\times n$的子块.
    + 比较相邻子块的灰度直方图相似性，相似则合并为同一区域
    + 反复第二步，直到区域不能合并为止.
    + 相似性的判断标准:
      + KS检测标准
      + SD检测标准
    + 难点:子块大小$n$的判断，根据经验$n$一般取$5\sim 10$



## 7.5  区域分裂合并法

+ 使用场景:事先不清楚区域形状和区域数目.
+ 基本原理：
  + 基于__四叉树思想__，把原始图像整体作为树根或零层，将图像等分成4块，作为被分裂的第一层.
  + 对于第一层的每一个子块，如果个像素属性一致，则不再等分.
  + 若属性不一致，则子块须继续分裂成相等的4块，作为第2层，如此循环.
  + 块的编号确定方式:
    + 第一层4块，从左上块开始，按照__顺时针方向__编号$1,2,3,4$，第2层以后每一块的标号方式一样，但下一层子块的编号是在它的上一层的标号后添加，当不再往下划分时，其尾数添加0.
+ 分裂、合并操作原则
  + 合并：当同一层的4块像素满足某一特性的均匀性时，就把他们合并为一个母块.
  + 分裂：当某一层的某一子块内像素不满足均匀条件时，将他们分裂成4个子块.
  + 均匀性可以看做灰度的均匀性或某种纹理特征的均匀性.
+ 具体步骤：
  + 初始分割：把一幅图像分裂到第二层($4*4=16$)
  + 合并处理:对第二层的每4个子块进行检查？？？？写的什么几把玩意，
  + 分裂处理:当第二层的每一个子块内像素不满足特性均匀性条件时，则吧他们分裂成4个子块.
  + 组合处理：以每块为中心，检查与其相邻的隔开
  + 消失小区：去你妈的...